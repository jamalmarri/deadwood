As discussed in class, functional cohesion is the best kind of
cohesion to use because it increases the clarity and reusability
of your code. We were able to make almost all of the classes in
our design functionally cohesive. The Board, Card, Part, Room,
and Set classes all serve to store information about a single
piece of the game. For instance, the Card class stores the name,
scene number, description, budget, and parts of a single card.
Each of these classes supports the action and state of one
aspect of the game, making them functionally cohesive. The
Player class is functionally cohesive because it similarly
supports the action and state of a single player by storing their
current room, dollars, credits, rank, etc., and then calculating
the playerâ€™s score at the end of the game. The Dice class may be
our most functionally cohesive class, with its only job being to
roll a given number of dice. The XMLParser class is functionally
cohesive because it deals with all of the parsing of the XML
files. The Screen class is functionally cohesive because it deals
with all aspects of user interaction. Finally, this leaves the
Deadwood class, which uses sequential cohesion. The actual order
of gameplay needed to be defined somewhere, including the setup
of the game at the beginning. This lends itself nicely to the
assembly line-like flow of sequential cohesion.

Our design for Deadwood has fairly loose coupling, which is
desirable because it also increases the clarity and reusability
of your code. The Deadwood class only interacts with the Board
through get methods, where no parameters are passed, so these two
classes are related through message coupling, the loosest and best
type. Similarly, the Board only interacts with Card objects through
get methods, so these two classes also use message coupling. Most
of the other coupling in our design is data coupling, which is
where only simple pieces of data are shared. The Board uses data
coupling with the XMLParser (inputs minor parameters such as what
room we want information about, then the XMLParser returns the
relevant parsed data from the XML files) and Room class (gets and
sets information about different rooms). The Deadwood class uses
data coupling with Dice (inputs a parameter for how many dice to
roll) and Player (gets and sets information about the players).
The data passed in all of these relationships seems unavoidable,
so data coupling is the best choice given the circumstances. Next,
we have one inheritance relationship in our design, which is a type
of type-use coupling. Set is a child class of Room, which we thought
would be a useful relationship because all of the rooms on the
Deadwood board have similar properties, but rooms that are sets have
several extra properties that need to be included as well. Finally,
the Deadwood class and the Screen are connected through control
coupling. Screen gets information from the users about what they want
to do, passing these control parameters on to Deadwood and affecting
the flow of the game. This type of coupling seems necessary here
because we want the users to affect the game, while at the same time
we also want to separate the view (Screen) and controller (Deadwood)
according to MVC.